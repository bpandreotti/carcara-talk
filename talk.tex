\documentclass[usepdftitle=false,aspectratio=169]{beamer}
\usepackage{amsmath, amsfonts, amssymb}
\usepackage{xspace}
\usepackage{xparse}
\usepackage[yyyymmdd]{datetime}
\usepackage{ulem}
\usepackage{array}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{stmaryrd}
\usepackage{subcaption}
\usepackage{bussproofs}
\usepackage{mathpartir}
\usepackage{minted}
\usemintedstyle{trac}

\usepackage{tikz}

\usetikzlibrary{shapes,arrows,positioning,decorations.markings,matrix,fit,calc}
\tikzstyle{line} = [draw, -latex']
\tikzstyle{rline} = [draw, latex'-]
\pgfdeclarelayer{background}
\pgfsetlayers{background,main}
\EnableBpAbbreviations

\hypersetup{
  pdftitle={Talk - Carcara: An efficient proof checker and elaborator for SMT
  proofs in the Alethe format - TACAS 2023},
  pdfauthor={Bruno Andreotti},
  pdfkeywords={},
  pdfborder={0 0 0}
  draft=false,
  bookmarksnumbered,
  bookmarksdepth=2,
  bookmarksopenlevel=2,
  bookmarksopen
}

\renewcommand{\dateseparator}{--}

%%% BEGIN Defining style
\useinnertheme[outline]{chamfered}
\setbeamertemplate{navigation symbols}{}%remove navigation symbols
\usefonttheme[onlymath]{serif}%beamer math looks like article math
\usecolortheme{seahorse}
\setbeamercolor{palette quinary}{use=structure,fg=black,bg=white}
%%% END Defining style

%%% BEGIN Biblatex for references
\usepackage[backend=bibtex,
doi=false,isbn=false,url=false,
% show initials only
style=alphabetic,
% Show name
% style=authoryear-icomp,
% citation label has 4 initials if up to 4 authors, 3 and "+" otherwise
maxalphanames= 4, maxcitenames = 3, minalphanames = 3, minnames = 3]{biblatex}
% citation label has first author's name et al
% maxcitenames=2,backend=biber]{biblatex}

\bibliography{./refs.bib}

%%%%%%%%%%%%% macros

\mathchardef\mhyphen="2D % Define a "math hyphen"

\usepackage{pifont}

\newcommand{\bluecheck}{{\color{blue}\checkmark}}
\newcommand{\redmark}{\color{red}{\ding{55}}}

\newcommand\vvthinspace{\kern+0.041667em}
\newcommand\vthinspace{\kern+0.083333em}
\newcommand\negvthinspace{\kern-0.083333em}
\newcommand\negvvthinspace{\kern-0.041667em}

\newcommand\FV[1]{\textrm{FV}(#1)}

\newcommand\sym[1]{\mathsf{#1}}

%ADT font macros
\newcommand{\typename}[1]{\mathbf{\mathrm{#1}}}
\newcommand{\consname}[1]{\mathrm{#1}}
\newcommand{\selname}[1]{\mathrm{#1}}
\newcommand{\testername}[1]{\mathrm{#1}}

\newcommand{\SInt}{\typename{Int}}
\newcommand{\SBool}{\typename{Bool}}
\newcommand{\SStr}{\typename{Str}}

\newcommand{\evalfn}[1]{\mathrm{eval}_{#1}}

\DeclareDocumentCommand{\qnt}{ O{n} m O{\psi}}{\innerqnt(#2,#1) #3}
\def\innerqnt(#1,#2,#3){#1 \bar #2.\>}

\DeclareDocumentCommand{\terms}{ m O{}}{\mathbf{T}_{#2}(#1)}

\DeclareDocumentCommand{\bfapp}{ O{f} m O{n}}{#1({\bar #2}_{#3})}
\DeclareDocumentCommand{\enum}{ O{n} m O{,\,} O{} O{1}}{#2_#5#4#3\dots #3#2_{#1}#4}
\DeclareDocumentCommand{\benum}{ O{n} m O{\mapsto} O{} O{,\,} O{1}}{\innerbenum(#2,#3,#6,#4)#5\dots #5\innerbenum(#2,#3,#1,#4)}
\def\innerbenum(#1,#2,#3,#4,#5){#1_{#4}#3 #5{#2_{#4}}}

\DeclareDocumentCommand{\bfenum}{O{\mapsto} m}{\innerbfenum(#2,#1)}
  \def\innerbfenum(#1,#2,#3){\bar #1#3 \bar #2}
\DeclareDocumentCommand{\fapp}{ O{f} m O{n} O{,\,} O{(} O{)}}{#1#5#2_1#4\dots #4#2_{#3}#6}

% Column that takes width (left justified): L{1cm}, e.g.
\newcolumntype{L}[1]{>{\raggedright\arraybackslash$} p{#1} <{$}}

% Column with math mode in displaystyle
\newcolumntype{F}[1]{>{$\displaystyle} #1 <{$}}

% Column with math mode in displaystyle
\newcolumntype{D}[1]{>{\displaystyle} #1 <{}}

% Allows to break like in cell; first arg is $t,b,c$, for alignment with other cells
\newcommand{\specialcell}[2][c]{%
  \begin{tabular}[#1]{@{}l@{}}#2\end{tabular}}

\newcommand{\ccfv}{\textsc{CCFV}}

% \newcommand{\cdclt}{CDCL($\mathcal{T}$)}
\newcommand{\cdclt}{CDCL(T)}
\newcommand{\dpllt}{\cdclt}

\newcommand{\cvcho}{\textsc{cvc}4-\textsc{ho}\xspace}
\newcommand{\cvc}{\textsc{cvc}4\xspace}
\newcommand{\zzz}{Z3}
\newcommand{\verit}{\textsc{veriT}\xspace}

\newcommand{\basestrat}[1]{{\bf #1}}
\newcommand\interleavestrat[2]{\basestrat{#1}+\basestrat{#2}}
\newcommand\mathinterleavestrat[2]{$\mathbf{#1}$+$\mathbf{#2}$}
\newcommand\prioritystrat[2]{\basestrat{#1};\basestrat{#2}}
\newcommand{\zbasestrat}[1]{{\bf z3 #1}}
\newcommand{\zprioritystrat}[2]{{\bf z3} \basestrat{#1};\basestrat{#2}}
\newcommand{\E}{\mathsf{E}}
\newcommand{\Q}{\mathsf{Q}}
\newcommand{\M}{\mathsf{M}}
\newcommand{\ite}{\mathsf{ite}}
\newcommand{\Mod}{\mathcal{M}}
\newcommand{\termordereq}{\preceq}
\newcommand{\termorder}{\prec}
\newcommand{\teq}{\simeq}
\newcommand{\tneq}{\not\simeq}

\newcommand{\inputform}{\psi}
\newcommand{\matrixform}{\varphi}

\newcommand\vitem{\vfill\item}
\newcommand\pvitem{\pause\vfill\item}
\newcommand\pitem{\pause\item}

\newcommand{\cvcsy}{\textsc{cvc}4\textsc{sy}\xspace}
\newcommand{\cvccegis}{\textsc{cvc+c}\xspace}
\newcommand{\cvcu}{\textsc{cvc+upi}\xspace}
\newcommand{\cvcuci}{\textsc{cvc+upi+e}\xspace}
\newcommand{\cvcport}{\textsc{cvc-port}\xspace}
\newcommand{\loopinv}{\textsc{loopinvgen}\xspace}

\newcommand{\divc}{D\&C\xspace}

% AJR : update these
\newcommand{\unif}{Unif+PI\xspace}
\newcommand{\unifci}{Unif+PI+E\xspace}
\newcommand{\smtclass}{\textsc{SMTClassify}\xspace}
\newcommand{\learn}{\textsc{Learn}\xspace}
\newcommand{\classchecker}{\textsc{ClassChecker}\xspace}

%%%%%%%%%%%%


% To avoid number in slides that break, like the references one
\setbeamertemplate{frametitle continuation}{}

% Small font
\renewcommand*{\bibfont}{\scriptsize}
%%% END Biblatex for references



%%% BEGIN DEFINING TITLE PAGE

\defbeamertemplate{title page}{mystyle}[1][]
{
  \vbox{}
  \vfill
  \begingroup
    \centering
    {\usebeamercolor[fg]{titlegraphic}\inserttitlegraphic\par}
    \vskip1em
    \begin{beamercolorbox}[sep=0pt,center,#1,rounded=true,wd=11cm]{title}
      \usebeamerfont{title}\inserttitle\par%
      \ifx\insertsubtitle\@empty%
      \else%
        \vskip0.25em%
        {\usebeamerfont{subtitle}\usebeamercolor[fg]{subtitle}\insertsubtitle\par}%
      \fi%
    \end{beamercolorbox}%
    \vskip1em\par
    \begin{beamercolorbox}[sep=8pt,center,#1]{author}
      \usebeamerfont{author}\insertauthor
    \end{beamercolorbox}
    \begin{beamercolorbox}[sep=8pt,center,#1]{institute}
      \usebeamerfont{institute}\insertinstitute
    \end{beamercolorbox}
    \begin{beamercolorbox}[sep=0pt,center,#1]{date}
      \usebeamerfont{date}\insertdate
    \end{beamercolorbox}%
  \endgroup
  \vfill
}

\setbeamertemplate{title page}[mystyle]

%%% END DEFINING TITLE PAGE

%%% BEGIN Meta information
\author[Bruno Andreotti]
{%
  \texorpdfstring{
    \emph{Bruno Andreotti}, Hanna Lachnitt, Haniel Barbosa\\
      \vspace{3ex}
    \begin{columns}
      \column{.45\linewidth}
        \centering
        \includegraphics[height=0.15\textheight]{images/Logo_UFMG.jpg}
      \column{.45\linewidth}
        \centering
        \includegraphics[height=0.13\textheight]{images/centaur.pdf}
        \includegraphics[height=0.05\textheight]{images/centaur-wordmark.png}
        \vspace{-1ex}
    \end{columns}
  }
  {}
}

\date{TACAS, ETAPS 2023 at Paris, France, 2023--04--24}

\title[Carcara: An efficient proof checker and elaborator for SMT proofs in the
Alethe format] {Carcara: An efficient proof checker and elaborator for SMT
proofs in the Alethe format}

% Redifining footer
\makeatother
\setbeamertemplate{footline}
{
  \leavevmode%
  \hbox{%
    \begin{beamercolorbox}[wd=.6\paperwidth,ht=2.5ex,dp=1ex,left]{title in head/foot}%
      {\hspace{1em}\usebeamerfont{title in head/foot}\insertshorttitle}
    \end{beamercolorbox}%
    \begin{beamercolorbox}[wd=.2\paperwidth,ht=2.5ex,dp=1ex,left]{title in head/foot}%
      {\hspace{1em}\usebeamerfont{title in head/foot}Bruno Andreotti, UFMG}
    \end{beamercolorbox}%
    \begin{beamercolorbox}[wd=.2\paperwidth,ht=2.5ex,dp=1ex,right]{title in head/foot}%
      \insertframenumber{} / \inserttotalframenumber\hspace{1em}
    \end{beamercolorbox}}%
  \vskip0pt%
}
\makeatletter
%%% END Meta information

%%% BEGIN Tikz setup
\usepackage{tikz}
\usetikzlibrary{positioning,calc,intersections,backgrounds, fadings}
\usetikzlibrary{shapes}

  \tikzset{
    invisible/.style={opacity=0},
    visible on/.style={alt=#1{}{invisible}},
    alt/.code args={<#1>#2#3}{%
      \alt<#1>{\pgfkeysalso{#2}}{\pgfkeysalso{#3}} % \pgfkeysalso doesn't change the path
    },
  }

\definecolor{BloodRed}{rgb}{.86,0,0}
\definecolor{gold(metallic)}{rgb}{0.83, 0.69, 0.22}

\definecolor{procColor}{rgb}{0.628,0.35,0.17}
\definecolor{cnfColor}{rgb}{0.82, 0.0, 0.86}
% \definecolor{cnfColor}{rgb}{.83,.66,0}
\definecolor{satColor}{rgb}{.83,0,0}
\definecolor{thSolverColor}{rgb}{0,.5,0}
\definecolor{thRwColor}{rgb}{0,0,1}
\definecolor{thCombColor}{rgb}{0.5,0.5,0}

% spec
\definecolor{spec}{rgb}{0.0, 0.0, 0.86}
% syntax recstrictions
\definecolor{grammar}{rgb}{0.82, 0.0, 0.86}

\tikzfading[
  name=arrowfading,
  top color=transparent!0,
  bottom color=transparent!95
]
\newcommand*{\tikzarrow}[2]{%
  \tikz[
    baseline=(A.base),             % Set baseline to the baseline of node content
    font=\footnotesize\sffamily    % Set fontsize of the node content
  ]
  \node[
    single arrow,                  % Shape of the node
    single arrow head extend=4pt,  % Actual width of arrow head
    single arrow tip angle=150,    % Adjust arrow tip angle
    shape border rotate=270,       % Rotate the arrow shape to point down
    draw=red!25,                   % Draw the node shape (with certain border color
    inner sep=2pt,                 % Separation between node content and node shape
    top color=white,               % Shading color on top of node
    bottom color=#1,               % Shading color on bottom of node
    general shadow={               % Specifications for the shadow
      fill=black,
      shadow yshift=-0.5ex,
      path fading=arrowfading
    }
  ] (A) {#2};%
}

%%% END Tikz setup

\newcommand{\qgo}[1]{\innerqgo(#1)}
    \def\innerqgo(#1,#2,#3){#1 #2_1\dots #2_n.３茕彐荞纾丙荛铑弪耒ǎ暴茕彐荛铑弪耒ǎ爆２３１茼狒桠纣２３苣邈灬蝈娘沲礤铘蔑眄犷潲荞玮消荛铑弪耒猕１２茕彐荛铑弪耒猕１２３４１茆狎２啕４３苣邈灬蝈娘沲礤铘蔑眄犷潲苕狃瘕消纨消铨消消消１５２弑４茕雉４２啕３６苣邈灬蝈娘沲礤铘蔑眄犷潲苕狃痖铘消纨消铨消荛铑弪驷痧轭舁１２３４茕彐荛铑弪驷痧轭舁１２３４５６１ǎ常策保矗盾滹趔６３２啕５４苣邈灬蝈娘沲礤铘蔑眄犷潲茆驷痧消纨消１ㄜ忉２啕３苣邈灬蝈娘沲礤铘蔑眄犷潲苠铛睚消铨消消消饼２撸担矗耻滹趔３２啕１４苣邈灬蝈娘沲礤铘蔑眄犷潲茆孱蹴消铨消茼狃篝稞消消墁消饼荛铑弪忮铛悫２３６４５茕雉５荛铑弪忮铛悫２３１４茕彐荛铑弪忮铛悫１２３４５１啕４５３２啕４５荃箦疳汶徵妍箫蹯泔祜螨荏弭篝泔祜螓蝈潺茼犭遽綮弭翦茴鬻泔眄犷滠语蹯蔑祜螓莒弭荏弭楞镬矧茆遽礤蝻蜷缋箦衾泔祜莒弭茯弩弭楞镬矧茆遽礤蝻蜷缋蝈箦衾泔祜螨茼犭遽麸翳弪苣邈灬蝈娘沲礤铘蔑眄犷潲荏秕趑栝汶消答酏茯孱鬻泔眄犷潲苷挑栝汶铄篌１荏秕酐２茯孱鬻泔眄犷潲苷挑栝汶铄篌答酏义箦趑轭麸蹯屙溴驷蹯茕彐轭邈镬矧犸蜱恺爱艾爱艾碑褒茕彐轭邈镬矧犸ㄥ铉扉箬蜱恺爱艾爱惮爱褒茕彐轭邈镬矧狍疳蜥珲簖蜱恺爱党爱抖爱床茕彐轭邈镬矧怙篝镱躅轹弪箝豉蝈潺蜱恺爱脯爱艾爱褒茕彐轭邈镬矧溽螂怛秣铨蜱恺爱船爱捕爱背茕彐轭邈镬矧犰辁狎轭蜱恺爱覆爱爆爱捕补挡怄骀茕彐轭邈镬矧沐蝓戾犷忪蹂蜱恺爱倍爱巢爱返搞鞍搞骀茕彐轭邈镬矧溽螂磲珏铘猃蜱恺爱档爱艾爱档８坡酶茕彐轭邈镬矧溽螂箦徵蝈孱蜱恺爱刀爱反爱刀荃箦疳汶徵妍糸膪耵蝈妪ゥゥゥゥゥゥゥゥ屡巧溴骈铄秕綮轭磲汨轭弪茴鬻泔眄犷潲茆遽礤蝮邈鄄蓰荏邈糸镱１茚滗泔铘孱趔扉铄麸泯箦泗轱铨ぼ怩祆弭１荟箴徙妍卑痿茴鬻扉铄荛钽祯溴珧狃栝泱坭彘玷艚耻翦翳彘玷糨２荟骈祆茆彗轭骝犴妪荟骈祆茆彗轭沐铘弪荟骈祆荇屮翕纣１荟骈祆荛钽祯溴珧狃栝泱坭彘玷艚弟翦翳彘玷糨２荟骈祆苠钿沐铘弪荟骈祆苠钿骝犴妪茴鬻泔眄犷潲茆遽礤蝮踱箦泯郾蓰荏踱箦泗轱瞠１茚滗泔铘孱趔扉铄麸泯箦泗轱铨ぼ礅秫荞踽洵１荟箴徙妍卑痿茴鬻扉铄荟骈祆茆彗轭骝犴妪荟骈祆茆彗轭沐铘弪荇屮翕纣１苠钿沐铘弪荟骈祆苠钿骝犴妪茴鬻泔眄犷潲茆遽礤蝮踱篚怏邈郾蓰荏踱箦泗轱瞠１茚滗泔铘孱趔扉铄麸泯箦泗轱铨ぼ礅秫荞聃徜茔滹簸１荟箴徙妍卑痿茴鬻扉铄荟骈祆ゥゥゥゥゥゥゥゥ盼溴骈铄秕綮轭磲汨轭弪ゥ屡巧趄殂骘铒泔躅糸铉蝈驽蝈钽弩茴鬻泔眄犷潲茆徙膈疴彗轭茴鬻泔躅翦螓骝犴孱蹴忮蜥痧孱溟荏弭泔躅翦螓骝犴孱蹴忮蜥痧孱溟荟犰蹂骝犴孱蹴忮螨茴鬻泔眄犷潲茆徙膈疱钿茚滗麸泔躅翦螓骝犴孱蹴忮蜥痧孱溟荟犰蹂骝犴孱蹴忮螨茚滗麸泔躅翦螓骝犴孱蹴忮螨荟犰蹂骝犴孱蹴忮蜥痧孱溟ゥ盼趄殂骘铒泔躅糸铉蝈驽蝈钽弩茴鬻泔眄犷潲茯邃郾蓰荇屮翥镬矧蝈潺１抿遽糸铉怙弩鏖翳鏖漪镦玳鲥翦艋骈蝮疳蜥礤翦镳糸镱犰轶犰殓铐孱镦怙翳孱翦麸忮翎脲翳鏖漪璎翳孱翳翦麸忮怙邃茴鬻戾铉翳荏翦赭殇翳茴鬻泔眄犷滠磲脲筢礤鏖漪枸齿坫蓰荏弭麸鏖漪棼荏翦赭殇翳２茼犭邂秫圮篝屮赭殇翳蒇１蓰３泔祜栝玷扉玷姘溷广骀芰袈彗轭渝泗轱钲蓰荏弭忮犴弪翦眇灬翦骘雉扉铄茆彗轭骝犴妪荟骈祆茔孱翦蜷铉茆彗轭忮犴弪泔祜蜮秫垠屦礁痿沐铘弪箬徜秣紧蝓瀣蝻躅溴浣趄蹂蓰糸綮妪荃箦忮犴弪骘铘糸綮妪荛铙弪趔邈糸镱桢徜莛狎苠钿忮犴弪泔祜蜮秫荟骈祆苠钿骝犴妪茚滗麸泔躅翦螓骝犴孱蹴忮螨饼澡屣蝈箦趑轭珞茚滗麸忮犴弪翦眇灬翦翳屣蝈忮玳铨荏弭忮犴弪泔祜螓忪镢糸綮妪骁谨栝翦忡解灬汶荏弭忮犴弪泔祜螓忪镢怙澌骁解灬汶忡谨栝翦」啊忪徙臊ゥ屡巧萌廖巧吻抡烫旁釉偬荏弭忮犴弪翦眇灬翦轸屙辁轸屙ぼ鲠螋蜷犷珈弪殓梏荏弭忮犴弪翦眇灬翦轸屙辁篚忾翦睚ぼ忪徙媵蜷犷珈弪殓梏茴鬻戾铉翳茱蜷珈彐繇狎玳铋荏弭戾铉翳茱蜷珈彐繇狎玳铋莒彐繇狎玳铋茴鬻戾铉翳茱蜷珈彐繇狎玳铋荏弭戾铉翳茱蜷珈彐繇狎玳铋檐戾骠磲蜱轭殚荏弭戾铉翳莒彐繇狎玳铋卞睚荏弭戾铉翳莒彐繇狎玳铋辂碑驳屙荏弭戾铉翳莒彐繇狎玳铋殚卞睚ゥ盼萌廖巧吻抡烫旁釉偬荏弭忮犴弪箝妍翦磲蜱轭戾骠奖屙翦磲蜱轭蜷玷艚碑靛睚茴鬻泔眄犷潲荠屐忑郾蓰荇屮翥镬矧蝈潺郏陛茴鬻泔眄犷潲茔鲢泯荇屮趔沱泠泯荏磲祆待荇屮趔沱簌荇屮趔沱恺茗箴徙妪茴鬻泔眄犷潲茔鲢猃荇屮趔沱泠泯荏磲祆待荇屮趔沱簌荇屮趔沱觚茗箴徙妪茴鬻泔眄犷潲茜痖潺荇屮趔沱切槟茗箴徙妪茴鬻泔眄犷潲苠痨衢铨荇屮趔沱砒痨衢铨茗箴徙妪茴鬻泔眄犷潲茼箦繇轭躞凝荑怙荇殡茕蜥髹扉铄鏖漪杞爱娥衄扉铄汜鸾蝻躅漭ǔ痿癌ò娥舂积茴鬻泔眄犷潲茼箦繇轭躞札茼箦繇轭躞凝茴鬻泔眄犷潲茼箦繇轭躞育荑怙荇殡茕蜥髹扉铄鏖漪杞爱吹痿扉铄汜鸾蝻躅漭ú痿癌ò答舂积茴鬻泔眄犷潲茼箦繇轭躞佑荑怙荇殡茕蜥髹扉铄鏖漪杞爱答衄扉铄汜鸾蝻躅漭ū叼衄癌ò仇舂积茴鬻泔眄犷潲茼箦繇轭躞茼狒桠轭茼狒桡栾殂妍茼箦繇轭躞凝茼箦繇轭躞札茼箦繇轭躞育茼箦繇轭躞佑茕彐荟鳆荏磲祆箅轲茴鬻泔眄犷潲荏屦茼殇

\begin{document}

{
\setbeamertemplate{footline}{}
\frame{\titlepage}
}
\addtocounter{framenumber}{-1}

\begin{frame}
  \frametitle{SMT solvers and trust}
  \begin{itemize}
    \vitem SMT solvers are crucial tools in many formal methods applications,
    like proof assistants and program verification
    \vitem However, these solvers often have large and complex codebases, which
    makes detecting bugs difficult
    \begin{itemize}
      \item Correctness bugs are often found in widely used SMT solvers, and
      every year SMT-COMP uncovers disagreements between solvers
    \end{itemize}
    \vitem Then, how can we trust the correctness of their results?
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Why certifying the solvers is not feasible}
  \begin{itemize}
    \vitem One possibility would be to certify the solver
    \vitem ...but their large, complex code bases would be too costly to certify
    \vitem ...and simplifying the system so it's easier to certify would mean
    compromising on performance
    \vitem Furthermore, certifying a system freezes it, slowing down the
    addition of new features and improvements
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{SMT proofs}
  \begin{itemize}
    \vitem Instead, the SMT sovler can produce a proof!
    \vitem An SMT proof is a certificate of the solver results, that formally
    justifies the logical resoning it used to find a solution
    \vitem Proofs can be checked independently, decoupling the confidence in the
    solvers results from the solver's implementation
    \vitem Checking is usually simpler and quicker than solving
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Alethe format}
  \begin{itemize}
    \vitem While in general SMT solvers use specific proof formats, Alethe is
    a new SMT proof format that aims to be usable by many different solvers
    \begin{itemize}
      \item It is currently supported by the veriT and cvc5 SMT solvers
    \end{itemize}
    \vitem In order to facilitate proof production, Alethe uses a term language
    that directly extends SMT-LIB
    \vitem Also to that end, Alethe provides rules with varying levels of
    granularity
    \vitem This allows solvers to rely on powerful checkers and produce
    coarse-grained proofs (which are easier to produce), while also allowing
    solvers to take the effort to produce more fine-grained proofs (which are
    easier to check)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Example}
  $$(\forall x \;.\; x \geq 0) \land \neg (\forall y \;.\; y \geq 0)$$
\end{frame}
\addtocounter{framenumber}{-1}

\begin{frame}
  \frametitle{Example}
  $$(\forall x \;.\; x \geq 0) \land \neg (\forall y \;.\; y \geq 0)$$
  \vfill
  \begin{prooftree}
    \AxiomC{}
    \RightLabel{\footnotesize\texttt{assume}}
    \UnaryInfC{$(\forall x \;.\; x \geq 0)$}
    \AxiomC{}
    \RightLabel{\footnotesize\texttt{assume}}
    \UnaryInfC{$\neg(\forall y \;.\; y \geq 0)$}
    \AxiomC{}
    \RightLabel{\footnotesize\texttt{refl}}
    \UnaryInfC{$x \mapsto y \vartriangleright\, x = y$}
    \RightLabel{\footnotesize\texttt{cong}}
    \UnaryInfC{$x \mapsto y \vartriangleright\, (x \geq 0) = (y \geq 0)$}
    \RightLabel{\footnotesize\texttt{bind}}
    \UnaryInfC{$(\forall x \;.\; x \geq 0) = (\forall y \;.\; y \geq 0)$}
    \RightLabel{\footnotesize\texttt{equiv1}}
    \UnaryInfC{$\neg (\forall x \;.\; x \geq 0) \lor (\forall y \;.\; y \geq 0)$}
    \RightLabel{\footnotesize\texttt{resolution}}
    \TrinaryInfC{$\bot$}
  \end{prooftree}
\end{frame}
\addtocounter{framenumber}{-1}

\begin{frame}[fragile]
  \frametitle{Example}
  \begin{minted}[autogobble, fontsize=\footnotesize, frame=single]{smtlib2.py -x}
    (set-logic LIA)
    (assert (forall ((x Int)) (>= x 0)))
    (assert (not (forall ((y Int)) (>= y 0))))
    (check-sat)
  \end{minted}
  \begin{prooftree}
    \AxiomC{}
    \RightLabel{\footnotesize\texttt{assume}}
    \UnaryInfC{$(\forall x \;.\; x \geq 0)$}
    \AxiomC{}
    \RightLabel{\footnotesize\texttt{assume}}
    \UnaryInfC{$\neg(\forall y \;.\; y \geq 0)$}
    \AxiomC{}
    \RightLabel{\footnotesize\texttt{refl}}
    \UnaryInfC{$x \mapsto y \vartriangleright\, x = y$}
    \RightLabel{\footnotesize\texttt{cong}}
    \UnaryInfC{$x \mapsto y \vartriangleright\, (x \geq 0) = (y \geq 0)$}
    \RightLabel{\footnotesize\texttt{bind}}
    \UnaryInfC{$(\forall x \;.\; x \geq 0) = (\forall y \;.\; y \geq 0)$}
    \RightLabel{\footnotesize\texttt{equiv1}}
    \UnaryInfC{$\neg (\forall x \;.\; x \geq 0) \lor (\forall y \;.\; y \geq 0)$}
    \RightLabel{\footnotesize\texttt{resolution}}
    \TrinaryInfC{$\bot$}
  \end{prooftree}
\end{frame}
\addtocounter{framenumber}{-1}

\begin{frame}[fragile]
  \frametitle{Example}
  \centering
  \begin{minted}[autogobble, fontsize=\footnotesize, frame=single]{smtlib2.py -x}
    (set-logic LIA)
    (assert (forall ((x Int)) (>= x 0)))
    (assert (not (forall ((y Int)) (>= y 0))))
    (check-sat)
  \end{minted}
  \begin{minted}[autogobble, fontsize=\footnotesize, frame=single]{smtlib2.py -x}
    (assume h1 (forall ((x Int)) (>= x 0)))
    (assume h2 (not (forall ((y Int)) (>= y 0))))
    (anchor :step t3 :args ((y Int) (:= x y)))
    (step t3.t1 (cl (= x y)) :rule refl)
    (step t3.t2 (cl (= (>= x 0) (>= y 0))) :rule cong :premises (t3.t1))
    (step t3 (cl (= (forall ((x Int)) (>= x 0)) (forall ((y Int)) (>= y 0))))
      :rule bind)
    (step t4 (cl (not (forall ((x Int)) (>= x 0))) (forall ((y Int)) (>= y 0)))
      :rule equiv1 :premises (t3))
    (step t5 (cl) :rule resolution :premises (t4 h1 h2))
  \end{minted}
\end{frame}

\begin{frame}
  \frametitle{Issues with checking Alethe proofs}
  \begin{itemize}
    \vitem Until now, Alethe proofs could only be checked via reconstruction in
    proof assistants
    \vitem This approach allows a lot of trust in the results, but has many
    limitations
    \begin{itemize}
      \item Performance
      \item Usability
    \end{itemize}
    \vitem Also, some SMT solvers produce very coarse-grained proofs, which can
    be very hard to check
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Issues with checking Alethe proofs}
  \begin{itemize}
    \vitem We need a tool that is independent, usable, and efficient in checking
    Alethe proofs
    \vitem Ideally, we would also want a tool that could improve the quality of
    proofs generated by SMT solvers
    \begin{itemize}
      \item This means turning a coarse-grained proof into a finer-grained
        one, making it easier to check
      \item We call this process "elaboration"
    \end{itemize}
    \vitem This elaboration procedure can be used as an intermediate step
    between solvers and proof assistants
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Introducing Carcara}
  \begin{itemize}
    \vitem Carcara is an efficient and independent proof checker and elaborator
    for Alethe proofs
    \vitem It is written in a high performance language, Rust
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Introducing Carcara}
  \centering
  \includegraphics[height=0.8\textheight]{images/architecture.png}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Checking Alethe proofs}
  \begin{minipage}{0.49 \textwidth}
  \begin{itemize}
    \vitem The first step in checking an Alethe proof is parsing it
    \vspace{4ex}
    \vitem Carcara uses \textit{hash consing} when parsing terms
    \vspace{4ex}
    \vitem The proof is represented internally by an array of proof commands
  \end{itemize}
  \end{minipage}
  \begin{minipage}{0.5 \textwidth}
    \vspace{-.35ex}
    \begin{minted}[autogobble, fontsize=\footnotesize, frame=single]{haskell}
      Proof [
        Assume {
          id: "h1",
          term: (forall ((x Int)) (> x 0)),
        },
        Assume {
          id: "h2",
          term: (not (forall ((y Int)) (> y 0))),
        },
        Subproof {
          args: [(y Int), (:= x y)]
          commands: [
            Step {
              id: "t3.t1",
              clause: [(= x y)],
              rule: "refl",
              premises: [],
            },
        ...
    \end{minted}
  \end{minipage}
\end{frame}

\begin{frame}
  \frametitle{Checking Alethe proofs}
  \begin{itemize}
    \vitem A checking procedure had to be implemented for each of the 90 rules
    currently in the Alethe format
    \vitem The presence of coarse-grained proof steps makes checking difficult
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Checking \textit{assume} commands}
  \begin{itemize}
    \vitem During parsing, the problem's assumptions are stored in a hash set
    \vitem In general, checking an \textit{assume} command amounts to accessing
    that hash set
    \vitem However, the solver may implicit reorder equalities when producing a
    proof
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Checking \textit{assume} commands}
  \begin{minipage}{0.54 \textwidth}
    \begin{itemize}
      \vitem An \texttt{assume} command may reference a problem premise while
      implicitly reordering an equality inside it
      \vspace{4ex}
      \vitem In this case, the checker must iterate through all the premises to
      find the correct one
    \end{itemize}
  \end{minipage}
  \begin{minipage}{0.45 \textwidth}
    \begin{minted}[autogobble, fontsize=\footnotesize, frame=single, escapeinside=||]{smtlib2.py -x}
      (set-logic QF_UF)
      (declare-const a Bool)
      (declare-const b Bool)
      (assert (= a b))
      (assert |\colorbox{yellow}{(not (= b a))}|)
      (check-sat)
    \end{minted}
    \begin{minted}[autogobble, fontsize=\footnotesize, frame=single, escapeinside=||]{smtlib2.py -x}
      (assume h1 (= a b))
      (assume h2 |\colorbox{yellow}{(not (= a b))}|)
      (step t3 (cl) :rule resolution
          :premises (h1 h2))
    \end{minted}
  \end{minipage}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Checking linear arithmetic steps}
  \begin{itemize}
    \vitem The \texttt{la\_generic} rule models linear arithmetic reasoning
    \vitem For example, consider this \texttt{la\_generic} step:
    \begin{minted}[autogobble, fontsize=\footnotesize, frame=single]{smtlib2.py -x}
      (step t1
        (cl (<= (- x) 1) (<= (+ (* 2 x) (* (- 3) y)) 2) (<= y (- 1)))
        :rule la_generic :args (2 1 3))
    \end{minted}
    \vitem It introduces the following tautology:
    $$(-x \leq 1) \lor (2x - 3y \leq 2) \lor (y \leq -1)$$
  \end{itemize}
\end{frame}

\begin{frame}[t, fragile]
  \frametitle{Checking linear arithmetic steps}
  \begin{minted}[autogobble, fontsize=\footnotesize, frame=single]{smtlib2.py -x}
    (step t1
      (cl (<= (- x) 1) (<= (+ (* 2 x) (* (- 3) y)) 2) (<= y (- 1)))
      :rule la_generic :args (2 1 3))
  \end{minted}
  \begin{itemize}
    \vitem Checking that this clause is true is equivalent to proving that its
    negation, the following three inequalites, are contradictory
  \end{itemize}
  \begin{align*}
    -x &> 1\tag{a}\\
    2x - 3y &> 2\tag{b}\\
    y &> -1\tag{c}
  \end{align*}
\end{frame}
\addtocounter{framenumber}{-1}

\begin{frame}[t, fragile]
  \frametitle{Checking linear arithmetic steps}
  \begin{minted}[autogobble, fontsize=\footnotesize, frame=single, escapeinside=||]{smtlib2.py -x}
    (step t1
      (cl (<= (- x) 1) (<= (+ (* 2 x) (* (- 3) y)) 2) (<= y (- 1)))
      :rule la_generic |\colorbox{yellow}{:args (2 1 3)}|)
  \end{minted}
  \begin{itemize}
    \vitem Since \texttt{la\_generic} steps provide the needed coefficients as
    arguments, checking them is simple
    \vitem Computing $2 \cdot (a) + 1 \cdot (b) + 3 \cdot (c)$, we get $0 > 1$,
    so the step must be true
  \end{itemize}
  \begin{align*}
    -x &> 1\tag{a}\\
    2x - 3y &> 2\tag{b}\\
    y &> -1\tag{c}
  \end{align*}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Checking linear arithmetic steps}
  \begin{itemize}
    \vitem The \texttt{lia\_generic} rule is very similar to
    \texttt{la\_generic}, but it does not provide the coefficients as arguments:
    \begin{minted}[autogobble, fontsize=\footnotesize, frame=single]{smtlib2.py -x}
      (step t1
        (cl (<= (- x) 1) (<= (+ (* 2 x) (* (- 3) y)) 2) (<= y (- 1)))
        :rule lia_generic)
    \end{minted}
    \vitem In this case, the checker would need to search for the coefficients,
    which an NP-Hard problem
    \vitem Instead, occurences of this rule are not checked, and are considered
    holes by Carcara
  \end{itemize}
\end{frame}

\begin{frame}[plain,allowframebreaks]{References}
\printbibliography
\end{frame}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
