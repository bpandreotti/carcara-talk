\documentclass[usepdftitle=false,aspectratio=169]{beamer}
\usepackage{amsmath, amsfonts, amssymb}
\usepackage{xspace}
\usepackage{xparse}
\usepackage[yyyymmdd]{datetime}
\usepackage{ulem}
\usepackage{array}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{stmaryrd}
\usepackage{subcaption}
\usepackage{bussproofs}
\usepackage{mathpartir}
\usepackage{minted}
\usemintedstyle{trac}

\usepackage{tikz}

\usetikzlibrary{shapes,arrows,positioning,decorations.markings,matrix,fit,calc}
\tikzstyle{line} = [draw, -latex']
\tikzstyle{rline} = [draw, latex'-]
\pgfdeclarelayer{background}
\pgfsetlayers{background,main}
\EnableBpAbbreviations

\hypersetup{
  pdftitle={Talk - Carcara: An efficient proof checker and elaborator for SMT
  proofs in the Alethe format - TACAS 2023},
  pdfauthor={Bruno Andreotti},
  pdfkeywords={},
  pdfborder={0 0 0}
  draft=false,
  bookmarksnumbered,
  bookmarksdepth=2,
  bookmarksopenlevel=2,
  bookmarksopen
}

\renewcommand{\dateseparator}{--}

%%% BEGIN Defining style
\useinnertheme[outline]{chamfered}
\setbeamertemplate{navigation symbols}{}%remove navigation symbols
\usefonttheme[onlymath]{serif}%beamer math looks like article math
\usecolortheme{seahorse}
\setbeamercolor{palette quinary}{use=structure,fg=black,bg=white}
%%% END Defining style

%%% BEGIN Biblatex for references
\usepackage[backend=bibtex,
doi=false,isbn=false,url=false,
% show initials only
style=alphabetic,
% Show name
% style=authoryear-icomp,
% citation label has 4 initials if up to 4 authors, 3 and "+" otherwise
maxalphanames= 4, maxcitenames = 3, minalphanames = 3, minnames = 3]{biblatex}
% citation label has first author's name et al
% maxcitenames=2,backend=biber]{biblatex}

\bibliography{./refs.bib}

%%%%%%%%%%%%% macros

\mathchardef\mhyphen="2D % Define a "math hyphen"

\usepackage{pifont}

\newcommand{\bluecheck}{{\color{blue}\checkmark}}
\newcommand{\redmark}{\color{red}{\ding{55}}}

\newcommand\vvthinspace{\kern+0.041667em}
\newcommand\vthinspace{\kern+0.083333em}
\newcommand\negvthinspace{\kern-0.083333em}
\newcommand\negvvthinspace{\kern-0.041667em}

\newcommand\FV[1]{\textrm{FV}(#1)}

\newcommand\sym[1]{\mathsf{#1}}

%ADT font macros
\newcommand{\typename}[1]{\mathbf{\mathrm{#1}}}
\newcommand{\consname}[1]{\mathrm{#1}}
\newcommand{\selname}[1]{\mathrm{#1}}
\newcommand{\testername}[1]{\mathrm{#1}}

\newcommand{\SInt}{\typename{Int}}
\newcommand{\SBool}{\typename{Bool}}
\newcommand{\SStr}{\typename{Str}}

\newcommand{\evalfn}[1]{\mathrm{eval}_{#1}}

\DeclareDocumentCommand{\qnt}{ O{n} m O{\psi}}{\innerqnt(#2,#1) #3}
\def\innerqnt(#1,#2,#3){#1 \bar #2.\>}

\DeclareDocumentCommand{\terms}{ m O{}}{\mathbf{T}_{#2}(#1)}

\DeclareDocumentCommand{\bfapp}{ O{f} m O{n}}{#1({\bar #2}_{#3})}
\DeclareDocumentCommand{\enum}{ O{n} m O{,\,} O{} O{1}}{#2_#5#4#3\dots #3#2_{#1}#4}
\DeclareDocumentCommand{\benum}{ O{n} m O{\mapsto} O{} O{,\,} O{1}}{\innerbenum(#2,#3,#6,#4)#5\dots #5\innerbenum(#2,#3,#1,#4)}
\def\innerbenum(#1,#2,#3,#4,#5){#1_{#4}#3 #5{#2_{#4}}}

\DeclareDocumentCommand{\bfenum}{O{\mapsto} m}{\innerbfenum(#2,#1)}
  \def\innerbfenum(#1,#2,#3){\bar #1#3 \bar #2}
\DeclareDocumentCommand{\fapp}{ O{f} m O{n} O{,\,} O{(} O{)}}{#1#5#2_1#4\dots #4#2_{#3}#6}

% Column that takes width (left justified): L{1cm}, e.g.
\newcolumntype{L}[1]{>{\raggedright\arraybackslash$} p{#1} <{$}}

% Column with math mode in displaystyle
\newcolumntype{F}[1]{>{$\displaystyle} #1 <{$}}

% Column with math mode in displaystyle
\newcolumntype{D}[1]{>{\displaystyle} #1 <{}}

% Allows to break like in cell; first arg is $t,b,c$, for alignment with other cells
\newcommand{\specialcell}[2][c]{%
  \begin{tabular}[#1]{@{}l@{}}#2\end{tabular}}

\newcommand{\ccfv}{\textsc{CCFV}}

% \newcommand{\cdclt}{CDCL($\mathcal{T}$)}
\newcommand{\cdclt}{CDCL(T)}
\newcommand{\dpllt}{\cdclt}

\newcommand{\cvcho}{\textsc{cvc}4-\textsc{ho}\xspace}
\newcommand{\cvc}{\textsc{cvc}4\xspace}
\newcommand{\zzz}{Z3}
\newcommand{\verit}{\textsc{veriT}\xspace}

\newcommand{\basestrat}[1]{{\bf #1}}
\newcommand\interleavestrat[2]{\basestrat{#1}+\basestrat{#2}}
\newcommand\mathinterleavestrat[2]{$\mathbf{#1}$+$\mathbf{#2}$}
\newcommand\prioritystrat[2]{\basestrat{#1};\basestrat{#2}}
\newcommand{\zbasestrat}[1]{{\bf z3 #1}}
\newcommand{\zprioritystrat}[2]{{\bf z3} \basestrat{#1};\basestrat{#2}}
\newcommand{\E}{\mathsf{E}}
\newcommand{\Q}{\mathsf{Q}}
\newcommand{\M}{\mathsf{M}}
\newcommand{\ite}{\mathsf{ite}}
\newcommand{\Mod}{\mathcal{M}}
\newcommand{\termordereq}{\preceq}
\newcommand{\termorder}{\prec}
\newcommand{\teq}{\simeq}
\newcommand{\tneq}{\not\simeq}

\newcommand{\inputform}{\psi}
\newcommand{\matrixform}{\varphi}

\newcommand\vitem{\vfill\item}
\newcommand\pvitem{\pause\vfill\item}
\newcommand\pitem{\pause\item}

\newcommand{\cvcsy}{\textsc{cvc}4\textsc{sy}\xspace}
\newcommand{\cvccegis}{\textsc{cvc+c}\xspace}
\newcommand{\cvcu}{\textsc{cvc+upi}\xspace}
\newcommand{\cvcuci}{\textsc{cvc+upi+e}\xspace}
\newcommand{\cvcport}{\textsc{cvc-port}\xspace}
\newcommand{\loopinv}{\textsc{loopinvgen}\xspace}

\newcommand{\divc}{D\&C\xspace}

% AJR : update these
\newcommand{\unif}{Unif+PI\xspace}
\newcommand{\unifci}{Unif+PI+E\xspace}
\newcommand{\smtclass}{\textsc{SMTClassify}\xspace}
\newcommand{\learn}{\textsc{Learn}\xspace}
\newcommand{\classchecker}{\textsc{ClassChecker}\xspace}

%%%%%%%%%%%%


% To avoid number in slides that break, like the references one
\setbeamertemplate{frametitle continuation}{}

% Small font
\renewcommand*{\bibfont}{\scriptsize}
%%% END Biblatex for references



%%% BEGIN DEFINING TITLE PAGE

\defbeamertemplate{title page}{mystyle}[1][]
{
  \vbox{}
  \vfill
  \begingroup
    \centering
    {\usebeamercolor[fg]{titlegraphic}\inserttitlegraphic\par}
    \vskip1em
    \begin{beamercolorbox}[sep=0pt,center,#1,rounded=true,wd=11cm]{title}
      \usebeamerfont{title}\inserttitle\par%
      \ifx\insertsubtitle\@empty%
      \else%
        \vskip0.25em%
        {\usebeamerfont{subtitle}\usebeamercolor[fg]{subtitle}\insertsubtitle\par}%
      \fi%
    \end{beamercolorbox}%
    \vskip1em\par
    \begin{beamercolorbox}[sep=8pt,center,#1]{author}
      \usebeamerfont{author}\insertauthor
    \end{beamercolorbox}
    \begin{beamercolorbox}[sep=8pt,center,#1]{institute}
      \usebeamerfont{institute}\insertinstitute
    \end{beamercolorbox}
    \begin{beamercolorbox}[sep=0pt,center,#1]{date}
      \usebeamerfont{date}\insertdate
    \end{beamercolorbox}%
  \endgroup
  \vfill
}

\setbeamertemplate{title page}[mystyle]

%%% END DEFINING TITLE PAGE

%%% BEGIN Meta information
\author[Bruno Andreotti]
{%
  \texorpdfstring{
    \emph{Bruno Andreotti}, Hanna Lachnitt, Haniel Barbosa\\
      \vspace{3ex}
    \begin{columns}
      \column{.45\linewidth}
        \centering
        \includegraphics[height=0.15\textheight]{images/Logo_UFMG.jpg}
      \column{.45\linewidth}
        \centering
        \includegraphics[height=0.13\textheight]{images/centaur.pdf}
        \includegraphics[height=0.05\textheight]{images/centaur-wordmark.png}
        \vspace{-1ex}
    \end{columns}
  }
  {}
}

\date{TACAS, ETAPS 2023 at Paris, France, 2023--04--24}

\title[Carcara: An efficient proof checker and elaborator for SMT proofs in the
Alethe format] {Carcara: An efficient proof checker and elaborator for SMT
proofs in the Alethe format}

% Redifining footer
\makeatother
\setbeamertemplate{footline}
{
  \leavevmode%
  \hbox{%
    \begin{beamercolorbox}[wd=.6\paperwidth,ht=2.5ex,dp=1ex,left]{title in head/foot}%
      {\hspace{1em}\usebeamerfont{title in head/foot}\insertshorttitle}
    \end{beamercolorbox}%
    \begin{beamercolorbox}[wd=.2\paperwidth,ht=2.5ex,dp=1ex,left]{title in head/foot}%
      {\hspace{1em}\usebeamerfont{title in head/foot}Bruno Andreotti, UFMG}
    \end{beamercolorbox}%
    \begin{beamercolorbox}[wd=.2\paperwidth,ht=2.5ex,dp=1ex,right]{title in head/foot}%
      \insertframenumber{} / \inserttotalframenumber\hspace{1em}
    \end{beamercolorbox}}%
  \vskip0pt%
}
\makeatletter
%%% END Meta information

%%% BEGIN Tikz setup
\usepackage{tikz}
\usetikzlibrary{positioning,calc,intersections,backgrounds, fadings}
\usetikzlibrary{shapes}

  \tikzset{
    invisible/.style={opacity=0},
    visible on/.style={alt=#1{}{invisible}},
    alt/.code args={<#1>#2#3}{%
      \alt<#1>{\pgfkeysalso{#2}}{\pgfkeysalso{#3}} % \pgfkeysalso doesn't change the path
    },
  }

\definecolor{BloodRed}{rgb}{.86,0,0}
\definecolor{gold(metallic)}{rgb}{0.83, 0.69, 0.22}

\definecolor{procColor}{rgb}{0.628,0.35,0.17}
\definecolor{cnfColor}{rgb}{0.82, 0.0, 0.86}
% \definecolor{cnfColor}{rgb}{.83,.66,0}
\definecolor{satColor}{rgb}{.83,0,0}
\definecolor{thSolverColor}{rgb}{0,.5,0}
\definecolor{thRwColor}{rgb}{0,0,1}
\definecolor{thCombColor}{rgb}{0.5,0.5,0}

% spec
\definecolor{spec}{rgb}{0.0, 0.0, 0.86}
% syntax recstrictions
\definecolor{grammar}{rgb}{0.82, 0.0, 0.86}

\tikzfading[
  name=arrowfading,
  top color=transparent!0,
  bottom color=transparent!95
]
\newcommand*{\tikzarrow}[2]{%
  \tikz[
    baseline=(A.base),             % Set baseline to the baseline of node content
    font=\footnotesize\sffamily    % Set fontsize of the node content
  ]
  \node[
    single arrow,                  % Shape of the node
    single arrow head extend=4pt,  % Actual width of arrow head
    single arrow tip angle=150,    % Adjust arrow tip angle
    shape border rotate=270,       % Rotate the arrow shape to point down
    draw=red!25,                   % Draw the node shape (with certain border color
    inner sep=2pt,                 % Separation between node content and node shape
    top color=white,               % Shading color on top of node
    bottom color=#1,               % Shading color on bottom of node
    general shadow={               % Specifications for the shadow
      fill=black,
      shadow yshift=-0.5ex,
      path fading=arrowfading
    }
  ] (A) {#2};%
}

%%% END Tikz setup

\newcommand{\qgo}[1]{\innerqgo(#1)}
    \def\innerqgo(#1,#2,#3){#1 #2_1\dots #2_n.~{#3}}
\def\qg#1{\innerqg(#1)}
    \def\innerqg(#1,#2,#3){#1\mathbf{#2}.~{#3}}
\DeclareDocumentCommand{\qgb}{ m O{} }{\innerqgb(#1,#2)}
\def\innerqgb(#1,#2,#3,#4){#1\bar #2_{#4}.~{#3}}
\DeclareDocumentCommand{\fapp}{ O{f} m O{n} O{,} O{(} O{)}}{#1#5#2_1#4\dots #4#2_{#3}#6}
\DeclareDocumentCommand{\fappint}{ O{f} m O{n} O{,}}{\innerfappint(#1,#2,#3,#4)}
  \def\innerfappint(#1,#2,#3,#4,#5,#6){#1(#3#2_1#4#6\dots #6#3#2_{#5}#4)}
\DeclareDocumentCommand{\bfapp}{ O{f} m O{}}{#1(\bar {#2}_{#3})}

\DeclareDocumentCommand{\enum}{ O{n} m O{,} O{} O{1}}{#2_#5#4#3\dots #3#2_{#1}#4}
\DeclareDocumentCommand{\benum}{ O{n} m O{\mapsto} O{} O{,\,} O{1}}{\innerbenum(#2,#3,#6,#4)#5\dots #5\innerbenum(#2,#3,#1,#4)}
  \def\innerbenum(#1,#2,#3,#4,#5){#1_{#4}#5#3 {#2_{#4}}#5}

\usepackage{soul,xcolor}

\setstcolor{red}
\makeatletter
\newcommand\SoulColor{%
  \let\set@color\beamerorig@set@color
  \let\reset@color\beamerorig@reset@color}
\makeatother

\DeclareDocumentCommand{\soutthick}{ O{.4pt} m }{%
    \renewcommand{\ULthickness}{#1}%
       \sout{#2}%
    \renewcommand{\ULthickness}{.4pt}% Resetting to ulem default
}

\definecolor{ao}{rgb}{0.0, 0.0, 1.0}
\definecolor{ao(english)}{rgb}{0.0, 0.5, 0.0}
\definecolor{asparagus}{rgb}{0.53, 0.66, 0.42}
\definecolor{bostonuniversityred}{rgb}{0.8, 0.0, 0.0}
\definecolor{darkbrown}{rgb}{0.4, 0.26, 0.13}
\definecolor{alizarin}{rgb}{0.82, 0.1, 0.26}
% 2952bfff
\definecolor{ceruleanblue}{rgb}{0.16, 0.32, 0.75}
% 8c008cff
\definecolor{darkmagenta}{rgb}{0.55, 0.0, 0.55}
% #8FBC8F
\definecolor{darkseagreen}{rgb}{0.56, 0.74, 0.56}

\usepackage{tikz-qtree}

%%%%%%%%%%%%%%%% BEGIN define outline machinery

\newcommand{\beamersec}[2]{%
  \section*{#1}
  \addcontentsline{toc}{section}{$\bullet$ #1 \vspace{10pt}\newline  \includegraphics[height=.3\textheight]{#2}\vfill}

  \begin{frame}
    \vfill
    \begin{center}
      \vfill\textbf{#1}\vfill
      \includegraphics[height=.5\textheight]{#2}
      \vfill
    \end{center}
    \vfill
  \end{frame}
}

\newcommand{\beamersubsec}[1]{%
  \subsection*{#1}
  \addcontentsline{toc}{section}{$\mbox{}\quad-$ #1 \vspace{10pt}\newline\vfill}

  \begin{frame}
    \vfill
    \begin{center}
      \textbf{#1}
    \end{center}
    \vfill
  \end{frame}
}

\newcommand{\beamersubsubsec}[1]{%
  \subsection*{#1}
  \addcontentsline{toc}{section}{$\mbox{}\qquad\cdot$ #1 \vspace{10pt}\newline\vfill}
}

%%%%%%%%%%%%%%%% END define outline machinery

%%% BEGIN trick for not counting references

\newcommand{\backupbegin}{
   \newcounter{framenumberappendix}
   \setcounter{framenumberappendix}{\value{framenumber}}
}
\newcommand{\backupend}{
   \addtocounter{framenumberappendix}{-\value{framenumber}}
   \addtocounter{framenumber}{\value{framenumberappendix}}
}

%%% END trick for not counting references

\newcommand{\red}[1]{\textcolor{red}{#1}}

% Creating boxes with width of given text; first parameter (optional) is
% alignment of box, then text to be taken the width, then the text to be boxed
\newlength\stextwidth
\newcommand\makesamewidth[3][c]{%
  \settowidth{\stextwidth}{#2}%
  \makebox[\stextwidth][#1]{#3}%
}

% color highlight
% f0dc9cff

\AtBeginSection[]{
  {
    \setbeamertemplate{footline}{}
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
\end{frame}
}
\addtocounter{framenumber}{-1}
}

% Theorem settings
\addtobeamertemplate{theorem begin}{%
  \setbeamercolor{block title}{fg=white,bg=black}%
  \setbeamercolor{block body}{fg=black, bg=white!90!black}%
}{}

%%% BEGIN CHANGING BULLETS STYLE

\setbeamertemplate{itemize item}{$\vartriangleright$}
\setbeamertemplate{itemize subitem}{$\blacktriangleright$}
\newlength\origleftmargini
\setlength\origleftmargini\leftmargini
\newlength\origleftmarginii
\setlength\origleftmarginii\leftmarginii
\setlength\leftmargini{1em}
\setlength\leftmarginii{1.25em}
\setlength\leftmarginiii{1em}

%%% END CHANGING BULLETS STYLE

\setbeamersize{text margin left=1em, text margin right=1.5em}

\newcommand{\yell}[1]{{\textcolor{red}{[#1]}}}

\newcommand{\cvcc}{\textsc{cvc}{\small 4}\textsc{sy}\textsc{+b}\xspace}
\newcommand{\cvca}{\textsc{cvc}{\small 4}\textsc{sy}\textsc{+u}\xspace}
\newcommand{\gpid}{\textsc{GPiD}\xspace}
\newcommand{\explain}{\textsc{Explain}\xspace}

\newcommand{\mysetminusD}{\hbox{\tikz{\draw[line width=0.6pt,line cap=round] (3pt,0) -- (0,6pt);}}}
\newcommand{\mysetminusT}{\mysetminusD}
\newcommand{\mysetminusS}{\hbox{\tikz{\draw[line width=0.45pt,line cap=round] (2pt,0) -- (0,4pt);}}}
\newcommand{\mysetminusSS}{\hbox{\tikz{\draw[line width=0.4pt,line cap=round] (1.5pt,0) -- (0,3pt);}}}

\newcommand{\mysetminus}{\mathbin{\mathchoice{\mysetminusD}{\mysetminusT}{\mysetminusS}{\mysetminusSS}}}

\def\vv{\smallskip}

\newcommand{\sep}{~\mid~}

\begin{document}

{
\setbeamertemplate{footline}{}
\frame{\titlepage}
}
\addtocounter{framenumber}{-1}

\begin{frame}
  \frametitle{SMT solvers and trust}
  \begin{itemize}
    \item SMT solvers are crucial tools in many formal methods applications,
    like proof assistants and program verification
    \vitem However, these solvers often have large and complex codebases, which
    makes detecting bugs difficult
    \begin{itemize}
      \item Correctness bugs are often found in widely used SMT solvers, and
      every year SMT-COMP uncovers disagreements between solvers
    \end{itemize}
    \vitem Then, how can we trust the correctness of their results?
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Why certifying the solvers is not feasible}
  \begin{itemize}
    \item One possibility would be to certify the solver
    \vitem ...but their large, complex code bases would be too costly to certify
    \vitem ...and simplifying the system so it's easier to certify would mean
    compromising on performance
    \vitem Furthermore, certifying a system freezes it, slowing down the
    addition of new features and improvements
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{SMT proofs}
  \begin{itemize}
    \item Instead, the SMT solver can produce a proof!
    \vitem An SMT proof is a certificate of the solver results, that formally
    justifies the logical resoning it used to find a solution
    \vitem Proofs can be checked independently, decoupling the confidence in the
    solver's results from the solver's implementation
    \vitem Checking is usually simpler and quicker than solving
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Alethe format}
  \begin{itemize}
    \item Alethe is a new SMT proof format that aims to be usable by many
    different solvers
    \begin{itemize}
      \item It is currently supported by the SMT solvers veriT and cvc5
    \end{itemize}
    \vitem In order to facilitate proof production, Alethe uses a term language
    that directly extends SMT-LIB
    \vitem Also to that end, Alethe provides rules with varying levels of
    granularity
    \vitem This allows solvers to rely on powerful checkers and produce
    coarse-grained proofs, or take the effort to produce more fine-grained
    proofs
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Example}
  $$(\forall x \;.\; x \geq 0) \land \neg (\forall y \;.\; y \geq 0)$$
\end{frame}
\addtocounter{framenumber}{-1}

\begin{frame}
  \frametitle{Example}
  $$(\forall x \;.\; x \geq 0) \land \neg (\forall y \;.\; y \geq 0)$$
  \vfill
  \begin{prooftree}
    \AxiomC{}
    \RightLabel{\footnotesize\texttt{assume}}
    \UnaryInfC{$(\forall x \;.\; x \geq 0)$}
    \AxiomC{}
    \RightLabel{\footnotesize\texttt{assume}}
    \UnaryInfC{$\neg(\forall y \;.\; y \geq 0)$}
    \AxiomC{}
    \RightLabel{\footnotesize\texttt{refl}}
    \UnaryInfC{$x \mapsto y \vartriangleright\, x = y$}
    \RightLabel{\footnotesize\texttt{cong}}
    \UnaryInfC{$x \mapsto y \vartriangleright\, (x \geq 0) = (y \geq 0)$}
    \RightLabel{\footnotesize\texttt{bind}}
    \UnaryInfC{$(\forall x \;.\; x \geq 0) = (\forall y \;.\; y \geq 0)$}
    \RightLabel{\footnotesize\texttt{equiv1}}
    \UnaryInfC{$\neg (\forall x \;.\; x \geq 0) \lor (\forall y \;.\; y \geq 0)$}
    \RightLabel{\footnotesize\texttt{resolution}}
    \TrinaryInfC{$\bot$}
  \end{prooftree}
\end{frame}
\addtocounter{framenumber}{-1}

\begin{frame}[fragile]
  \frametitle{Example}
  \begin{minted}[autogobble, fontsize=\footnotesize, frame=single]{smtlib2.py -x}
    (set-logic LIA)
    (assert (forall ((x Int)) (>= x 0)))
    (assert (not (forall ((y Int)) (>= y 0))))
    (check-sat)
  \end{minted}
  \begin{prooftree}
    \AxiomC{}
    \RightLabel{\footnotesize\texttt{assume}}
    \UnaryInfC{$(\forall x \;.\; x \geq 0)$}
    \AxiomC{}
    \RightLabel{\footnotesize\texttt{assume}}
    \UnaryInfC{$\neg(\forall y \;.\; y \geq 0)$}
    \AxiomC{}
    \RightLabel{\footnotesize\texttt{refl}}
    \UnaryInfC{$x \mapsto y \vartriangleright\, x = y$}
    \RightLabel{\footnotesize\texttt{cong}}
    \UnaryInfC{$x \mapsto y \vartriangleright\, (x \geq 0) = (y \geq 0)$}
    \RightLabel{\footnotesize\texttt{bind}}
    \UnaryInfC{$(\forall x \;.\; x \geq 0) = (\forall y \;.\; y \geq 0)$}
    \RightLabel{\footnotesize\texttt{equiv1}}
    \UnaryInfC{$\neg (\forall x \;.\; x \geq 0) \lor (\forall y \;.\; y \geq 0)$}
    \RightLabel{\footnotesize\texttt{resolution}}
    \TrinaryInfC{$\bot$}
  \end{prooftree}
\end{frame}
\addtocounter{framenumber}{-1}

\begin{frame}[fragile]
  \frametitle{Example}
  \centering
  \begin{minted}[autogobble, fontsize=\footnotesize, frame=single]{smtlib2.py -x}
    (set-logic LIA)
    (assert (forall ((x Int)) (>= x 0)))
    (assert (not (forall ((y Int)) (>= y 0))))
    (check-sat)
  \end{minted}
  \begin{minted}[autogobble, fontsize=\footnotesize, frame=single]{smtlib2.py -x}
    (assume h1 (forall ((x Int)) (>= x 0)))
    (assume h2 (not (forall ((y Int)) (>= y 0))))
    (anchor :step t3 :args ((y Int) (:= x y)))
    (step t3.t1 (cl (= x y)) :rule refl)
    (step t3.t2 (cl (= (>= x 0) (>= y 0))) :rule cong :premises (t3.t1))
    (step t3 (cl (= (forall ((x Int)) (>= x 0)) (forall ((y Int)) (>= y 0))))
      :rule bind)
    (step t4 (cl (not (forall ((x Int)) (>= x 0))) (forall ((y Int)) (>= y 0)))
      :rule equiv1 :premises (t3))
    (step t5 (cl) :rule resolution :premises (t4 h1 h2))
  \end{minted}
\end{frame}

\begin{frame}
  \frametitle{Issues with checking Alethe proofs}
  \begin{itemize}
    \item Until now, Alethe proofs could only be checked via reconstruction in
    proof assistants
    \vitem This approach allows a lot of trust in the results, but has many
    limitations
    \begin{itemize}
      \item Performance
      \item Usability
    \end{itemize}
    \vitem Also, some SMT solvers produce very coarse-grained proofs, which can
    be very hard to check
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Issues with checking Alethe proofs}
  \begin{itemize}
    \item We need a tool that is independent, usable, and efficient in checking
    Alethe proofs
    \vitem Ideally, we would also want a tool that could improve the quality of
    proofs generated by SMT solvers
    \begin{itemize}
      \item This means turning a coarse-grained proof into a finer-grained
        one, making it easier to check
      \item We call this process "elaboration"
    \end{itemize}
    \vitem This elaboration procedure can be used as an intermediate step
    between solvers and proof assistants
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Introducing Carcara}
  \begin{minipage}[c][0.6 \textheight]{0.55 \textwidth}
    \begin{itemize}
      \item Carcara is an efficient and independent proof checker and
      elaborator for Alethe proofs
      \vitem It is written in Rust, a high performance language
      \vitem It is available as a command line program, but also provides a Rust
      API
    \end{itemize}
  \end{minipage}
  \begin{minipage}{0.44 \textwidth}
    \centering
    \includegraphics[height=0.6\textheight]{images/architecture.png}
  \end{minipage}
\end{frame}

\section{Checking}

\begin{frame}[fragile]
  \frametitle{Checking Alethe proofs}
  \begin{minipage}[c][0.6 \textheight]{0.49 \textwidth}
  \begin{itemize}
    \item The first step in checking an Alethe proof is parsing it
    \vitem Carcara uses \textit{hash consing} when parsing terms
    \vitem The proof is represented internally by an array of proof commands
  \end{itemize}
  \end{minipage}
  \begin{minipage}{0.5 \textwidth}
    \vspace{-.35ex}
    \begin{minted}[autogobble, fontsize=\footnotesize, frame=single]{haskell}
      Proof [
        Assume {
          id: "h1",
          term: (forall ((x Int)) (> x 0)),
        },
        Assume {
          id: "h2",
          term: (not (forall ((y Int)) (> y 0))),
        },
        Subproof {
          args: [(y Int), (:= x y)]
          commands: [
            Step {
              id: "t3.t1",
              clause: [(= x y)],
              rule: "refl",
              premises: [],
            },
        ...
    \end{minted}
  \end{minipage}
\end{frame}

\begin{frame}
  \frametitle{Checking Alethe proofs}
  \begin{itemize}
    \item A checking procedure had to be implemented for each of the 90 rules
    currently in the Alethe format
    \vitem The presence of coarse-grained proof steps makes checking difficult
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Checking \textit{assume} commands}
  \begin{itemize}
    \item During parsing, the problem's assumptions are stored in a hash set
    \vitem In general, checking an \textit{assume} command amounts to accessing
    that hash set
    \vitem However, the solver may implicit reorder equalities when producing a
    proof
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Checking \textit{assume} commands}
  \begin{minipage}[c][0.45 \textheight]{0.54 \textwidth}
    \begin{itemize}
      \item An \texttt{assume} command may reference a problem premise while
      implicitly reordering an equality inside it
      \vitem In this case, the checker must iterate through all the premises to
      find the correct one
    \end{itemize}
  \end{minipage}
  \begin{minipage}{0.45 \textwidth}
    \begin{minted}[autogobble, fontsize=\footnotesize, frame=single, escapeinside=||]{smtlib2.py -x}
      (set-logic QF_UF)
      (declare-const a Bool)
      (declare-const b Bool)
      (assert (= a b))
      (assert |\colorbox{yellow}{(not (= b a))}|)
      (check-sat)
    \end{minted}
    \begin{minted}[autogobble, fontsize=\footnotesize, frame=single, escapeinside=||]{smtlib2.py -x}
      (assume h1 (= a b))
      (assume h2 |\colorbox{yellow}{(not (= a b))}|)
      (step t3 (cl) :rule resolution
          :premises (h1 h2))
    \end{minted}
  \end{minipage}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Checking linear arithmetic steps}
  \begin{itemize}
    \item The \texttt{la\_generic} rule models linear arithmetic reasoning
    \vitem For example, consider this \texttt{la\_generic} step:
    \begin{minted}[autogobble, fontsize=\footnotesize, frame=single]{smtlib2.py -x}
      (step t1
          (cl (<= (- x) 1) (<= (+ (* 2 x) (* (- 3) y)) 2) (<= y (- 1)))
          :rule la_generic :args (2 1 3))
    \end{minted}
    \vitem It introduces the following tautology:
    $$(-x \leq 1) \lor (2x - 3y \leq 2) \lor (y \leq -1)$$
  \end{itemize}
\end{frame}

\begin{frame}[t, fragile]
  \frametitle{Checking linear arithmetic steps}
  \begin{minted}[autogobble, fontsize=\footnotesize, frame=single]{smtlib2.py -x}
    (step t1
        (cl (<= (- x) 1) (<= (+ (* 2 x) (* (- 3) y)) 2) (<= y (- 1)))
        :rule la_generic :args (2 1 3))
  \end{minted}
  \begin{itemize}
    \item Checking that this clause is true is equivalent to proving that its
    negation, the following three inequalites, are contradictory
  \end{itemize}
  \begin{align*}
    -x &> 1\tag{a}\\
    2x - 3y &> 2\tag{b}\\
    y &> -1\tag{c}
  \end{align*}
\end{frame}
\addtocounter{framenumber}{-1}

\begin{frame}[t, fragile]
  \frametitle{Checking linear arithmetic steps}
  \begin{minted}[autogobble, fontsize=\footnotesize, frame=single, escapeinside=||]{smtlib2.py -x}
    (step t1
        (cl (<= (- x) 1) (<= (+ (* 2 x) (* (- 3) y)) 2) (<= y (- 1)))
        :rule la_generic |\colorbox{yellow}{:args (2 1 3)}|)
  \end{minted}
  \begin{itemize}
    \item Since \texttt{la\_generic} steps provide the needed coefficients as
    arguments, checking them is simple
    \vitem Computing $2 \cdot (a) + 1 \cdot (b) + 3 \cdot (c)$, we get $0 > 1$,
    so the step must be true
  \end{itemize}
  \begin{align*}
    -x &> 1\tag{a}\\
    2x - 3y &> 2\tag{b}\\
    y &> -1\tag{c}
  \end{align*}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Checking linear arithmetic steps}
  \begin{itemize}
    \item The \texttt{lia\_generic} rule is very similar to
    \texttt{la\_generic}, but it does not provide the coefficients as arguments:
    \begin{minted}[autogobble, fontsize=\footnotesize, frame=single]{smtlib2.py -x}
      (step t1
          (cl (<= (- x) 1) (<= (+ (* 2 x) (* (- 3) y)) 2) (<= y (- 1)))
          :rule lia_generic)
    \end{minted}
    \vitem In this case, the checker would need to search for the coefficients,
    which is an NP-Hard problem
    \vitem Instead, occurences of this rule are not checked, and are considered
    holes by Carcara
  \end{itemize}
\end{frame}

\section{Elaboration}

\begin{frame}
  \frametitle{Proof elaboration}
  \begin{itemize}
    \item There are many rules in Alethe which allow very coarse-grained steps
    \vitem By breaking them down into smaller, finer-grained steps, we can
    produce a proof that is easier to check and contains less holes
    \vitem Carcara implements elaboration procedures for a few important rules
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A motivating example: transitivity}
  \begin{itemize}
    \item In Alethe, \texttt{eq\_transitive} is one of the rules that reasons
    about the transitivity of equality
    \vitem In general, a step of this rule looks like this:
    \begin{minted}[autogobble, fontsize=\footnotesize, frame=single]{smtlib2.py -x}
      (step t1 (cl (not (= a b)) (not (= b c)) (not (= c d)) (= a d)) :rule eq_transitive)
    \end{minted}
    \vitem In a more natural notation, it introduces the tautology:
    $$(a \neq b) \lor (b \neq c) \lor (c \neq d) \lor (a = d)$$
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A motivating example: transitivity}
  \begin{itemize}
    \item However, the specification of this rule is very permissive
    \begin{itemize}
      \item The order of the transitive chain may be shuffled
      \item Each negated equality may also be flipped
    \end{itemize}
    \vitem Therefore, the following is also a valid \texttt{eq\_transitive}
    step:
    \begin{minted}[autogobble, fontsize=\footnotesize, frame=single]{smtlib2.py -x}
      (step t1 (cl (not (= b a)) (not (= c d)) (not (= c b)) (= a d)) :rule eq_transitive)
    \end{minted}
    \vitem This means that checking \texttt{eq\_transitive} is in general quadratic on
    the length of the clause (instead of linear)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Elaborating \texttt{eq\_transitive}}
  \begin{itemize}
    \item A possible elaboration procedure for \texttt{eq\_transitive} might
    change the clause to ``unshuffle'' the transitive chain, and ``unflip'' the
    needed equalities
    \vitem However, steps later in the proof may refer to the
    \texttt{eq\_transitive} step as premise, so we can't just change the
    conclusion caluse
    \vitem Instead, we must also add  steps that reconstruct the original
    clause, so that it can still be referenced further down in the proof
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Elaborating \texttt{eq\_transitive}}
  \begin{itemize}
    \item Here is an example \texttt{eq\_transitive} step:
    \begin{minted}[autogobble, fontsize=\footnotesize, frame=single]{smtlib2.py -x}
      (step t1 (cl (not (= b a)) (not (= c d)) (not (= c b)) (= a d)) :rule eq_transitive)
    \end{minted}
    \vitem ...and here is its elaboration:
    \begin{minted}[autogobble, fontsize=\footnotesize, frame=single]{smtlib2.py -x}
      (step t1.t1 (cl (not (= a b)) (not (= b c)) (not (= c d)) (= a d)) :rule eq_transitive)
      (step t1.t2 (cl (not (= b a)) (= a b)) :rule eq_symmetric)
      (step t1.t3 (cl (not (= c b)) (= b c)) :rule eq_symmetric)
      (step t1.t4 (cl (not (= c d)) (= a d) (not (= b a)) (not (= c b)))
          :rule resolution :premises (t1.t1 t1.t2 t1.t3))
      (step t1 (cl (not (= b a)) (not (= c d)) (not (= c b)) (= a d))
          :rule reordering :premises (t1.t4))
    \end{minted}
    \vitem The new \texttt{eq\_transitive} step, \texttt{t1.t1}, is now easy to
    check, and the step \texttt{t1} still has the same conclusion clause
  \end{itemize}
\end{frame}

\begin{frame}[plain,allowframebreaks]{References}
\printbibliography
\end{frame}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
